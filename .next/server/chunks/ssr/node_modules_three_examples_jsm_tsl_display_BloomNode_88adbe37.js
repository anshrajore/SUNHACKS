module.exports = {

"[project]/node_modules/three/examples/jsm/tsl/display/BloomNode.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "bloom": (()=>bloom),
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.core.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$webgpu$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.webgpu.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.tsl.js [app-ssr] (ecmascript)");
;
;
const _quadMesh = /*@__PURE__*/ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$webgpu$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["QuadMesh"]();
const _size = /*@__PURE__*/ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"]();
const _BlurDirectionX = /*@__PURE__*/ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"](1.0, 0.0);
const _BlurDirectionY = /*@__PURE__*/ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"](0.0, 1.0);
let _rendererState;
/**
 * Post processing node for creating a bloom effect.
 * ```js
 * const postProcessing = new THREE.PostProcessing( renderer );
 *
 * const scenePass = pass( scene, camera );
 * const scenePassColor = scenePass.getTextureNode( 'output' );
 *
 * const bloomPass = bloom( scenePassColor );
 *
 * postProcessing.outputNode = scenePassColor.add( bloomPass );
 * ```
 * By default, the node affects the entire image. For a selective bloom,
 * use the `emissive` material property to control which objects should
 * contribute to bloom or not. This can be achieved via MRT.
 * ```js
 * const postProcessing = new THREE.PostProcessing( renderer );
 *
 * const scenePass = pass( scene, camera );
 * scenePass.setMRT( mrt( {
 * 	output,
 * 	emissive
 * } ) );
 *
 * const scenePassColor = scenePass.getTextureNode( 'output' );
 * const emissivePass = scenePass.getTextureNode( 'emissive' );
 *
 * const bloomPass = bloom( emissivePass );
 * postProcessing.outputNode = scenePassColor.add( bloomPass );
 * ```
 * @augments TempNode
 * @three_import import { bloom } from 'three/addons/tsl/display/BloomNode.js';
 */ class BloomNode extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$webgpu$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["TempNode"] {
    static get type() {
        return 'BloomNode';
    }
    /**
	 * Constructs a new bloom node.
	 *
	 * @param {Node<vec4>} inputNode - The node that represents the input of the effect.
	 * @param {number} [strength=1] - The strength of the bloom.
	 * @param {number} [radius=0] - The radius of the bloom.
	 * @param {number} [threshold=0] - The luminance threshold limits which bright areas contribute to the bloom effect.
	 */ constructor(inputNode, strength = 1, radius = 0, threshold = 0){
        super('vec4');
        /**
		 * The node that represents the input of the effect.
		 *
		 * @type {Node<vec4>}
		 */ this.inputNode = inputNode;
        /**
		 * The strength of the bloom.
		 *
		 * @type {UniformNode<float>}
		 */ this.strength = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["uniform"])(strength);
        /**
		 * The radius of the bloom.
		 *
		 * @type {UniformNode<float>}
		 */ this.radius = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["uniform"])(radius);
        /**
		 * The luminance threshold limits which bright areas contribute to the bloom effect.
		 *
		 * @type {UniformNode<float>}
		 */ this.threshold = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["uniform"])(threshold);
        /**
		 * Can be used to tweak the extracted luminance from the scene.
		 *
		 * @type {UniformNode<float>}
		 */ this.smoothWidth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["uniform"])(0.01);
        /**
		 * An array that holds the render targets for the horizontal blur passes.
		 *
		 * @private
		 * @type {Array<RenderTarget>}
		 */ this._renderTargetsHorizontal = [];
        /**
		 * An array that holds the render targets for the vertical blur passes.
		 *
		 * @private
		 * @type {Array<RenderTarget>}
		 */ this._renderTargetsVertical = [];
        /**
		 * The number if blur mips.
		 *
		 * @private
		 * @type {number}
		 */ this._nMips = 5;
        /**
		 * The render target for the luminance pass.
		 *
		 * @private
		 * @type {RenderTarget}
		 */ this._renderTargetBright = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RenderTarget"](1, 1, {
            depthBuffer: false,
            type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HalfFloatType"]
        });
        this._renderTargetBright.texture.name = 'UnrealBloomPass.bright';
        this._renderTargetBright.texture.generateMipmaps = false;
        //
        for(let i = 0; i < this._nMips; i++){
            const renderTargetHorizontal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RenderTarget"](1, 1, {
                depthBuffer: false,
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HalfFloatType"]
            });
            renderTargetHorizontal.texture.name = 'UnrealBloomPass.h' + i;
            renderTargetHorizontal.texture.generateMipmaps = false;
            this._renderTargetsHorizontal.push(renderTargetHorizontal);
            const renderTargetVertical = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RenderTarget"](1, 1, {
                depthBuffer: false,
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HalfFloatType"]
            });
            renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;
            renderTargetVertical.texture.generateMipmaps = false;
            this._renderTargetsVertical.push(renderTargetVertical);
        }
        /**
		 * The material for the composite pass.
		 *
		 * @private
		 * @type {?NodeMaterial}
		 */ this._compositeMaterial = null;
        /**
		 * The material for the luminance pass.
		 *
		 * @private
		 * @type {?NodeMaterial}
		 */ this._highPassFilterMaterial = null;
        /**
		 * The materials for the blur pass.
		 *
		 * @private
		 * @type {Array<NodeMaterial>}
		 */ this._separableBlurMaterials = [];
        /**
		 * The result of the luminance pass as a texture node for further processing.
		 *
		 * @private
		 * @type {TextureNode}
		 */ this._textureNodeBright = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["texture"])(this._renderTargetBright.texture);
        /**
		 * The result of the first blur pass as a texture node for further processing.
		 *
		 * @private
		 * @type {TextureNode}
		 */ this._textureNodeBlur0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["texture"])(this._renderTargetsVertical[0].texture);
        /**
		 * The result of the second blur pass as a texture node for further processing.
		 *
		 * @private
		 * @type {TextureNode}
		 */ this._textureNodeBlur1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["texture"])(this._renderTargetsVertical[1].texture);
        /**
		 * The result of the third blur pass as a texture node for further processing.
		 *
		 * @private
		 * @type {TextureNode}
		 */ this._textureNodeBlur2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["texture"])(this._renderTargetsVertical[2].texture);
        /**
		 * The result of the fourth blur pass as a texture node for further processing.
		 *
		 * @private
		 * @type {TextureNode}
		 */ this._textureNodeBlur3 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["texture"])(this._renderTargetsVertical[3].texture);
        /**
		 * The result of the fifth blur pass as a texture node for further processing.
		 *
		 * @private
		 * @type {TextureNode}
		 */ this._textureNodeBlur4 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["texture"])(this._renderTargetsVertical[4].texture);
        /**
		 * The result of the effect is represented as a separate texture node.
		 *
		 * @private
		 * @type {PassTextureNode}
		 */ this._textureOutput = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["passTexture"])(this, this._renderTargetsHorizontal[0].texture);
        /**
		 * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders
		 * its effect once per frame in `updateBefore()`.
		 *
		 * @type {string}
		 * @default 'frame'
		 */ this.updateBeforeType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$webgpu$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["NodeUpdateType"].FRAME;
    }
    /**
	 * Returns the result of the effect as a texture node.
	 *
	 * @return {PassTextureNode} A texture node that represents the result of the effect.
	 */ getTextureNode() {
        return this._textureOutput;
    }
    /**
	 * Sets the size of the effect.
	 *
	 * @param {number} width - The width of the effect.
	 * @param {number} height - The height of the effect.
	 */ setSize(width, height) {
        let resx = Math.round(width / 2);
        let resy = Math.round(height / 2);
        this._renderTargetBright.setSize(resx, resy);
        for(let i = 0; i < this._nMips; i++){
            this._renderTargetsHorizontal[i].setSize(resx, resy);
            this._renderTargetsVertical[i].setSize(resx, resy);
            this._separableBlurMaterials[i].invSize.value.set(1 / resx, 1 / resy);
            resx = Math.round(resx / 2);
            resy = Math.round(resy / 2);
        }
    }
    /**
	 * This method is used to render the effect once per frame.
	 *
	 * @param {NodeFrame} frame - The current node frame.
	 */ updateBefore(frame) {
        const { renderer } = frame;
        _rendererState = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$webgpu$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["RendererUtils"].resetRendererState(renderer, _rendererState);
        //
        const size = renderer.getDrawingBufferSize(_size);
        this.setSize(size.width, size.height);
        // 1. Extract bright areas
        renderer.setRenderTarget(this._renderTargetBright);
        _quadMesh.material = this._highPassFilterMaterial;
        _quadMesh.render(renderer);
        // 2. Blur all the mips progressively
        let inputRenderTarget = this._renderTargetBright;
        for(let i = 0; i < this._nMips; i++){
            _quadMesh.material = this._separableBlurMaterials[i];
            this._separableBlurMaterials[i].colorTexture.value = inputRenderTarget.texture;
            this._separableBlurMaterials[i].direction.value = _BlurDirectionX;
            renderer.setRenderTarget(this._renderTargetsHorizontal[i]);
            _quadMesh.render(renderer);
            this._separableBlurMaterials[i].colorTexture.value = this._renderTargetsHorizontal[i].texture;
            this._separableBlurMaterials[i].direction.value = _BlurDirectionY;
            renderer.setRenderTarget(this._renderTargetsVertical[i]);
            _quadMesh.render(renderer);
            inputRenderTarget = this._renderTargetsVertical[i];
        }
        // 3. Composite all the mips
        renderer.setRenderTarget(this._renderTargetsHorizontal[0]);
        _quadMesh.material = this._compositeMaterial;
        _quadMesh.render(renderer);
        // restore
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$webgpu$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["RendererUtils"].restoreRendererState(renderer, _rendererState);
    }
    /**
	 * This method is used to setup the effect's TSL code.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @return {PassTextureNode}
	 */ setup(builder) {
        // luminosity high pass material
        const luminosityHighPass = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Fn"])(()=>{
            const texel = this.inputNode;
            const v = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["luminance"])(texel.rgb);
            const alpha = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["smoothstep"])(this.threshold, this.threshold.add(this.smoothWidth), v);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mix"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["vec4"])(0), texel, alpha);
        });
        this._highPassFilterMaterial = this._highPassFilterMaterial || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$webgpu$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["NodeMaterial"]();
        this._highPassFilterMaterial.fragmentNode = luminosityHighPass().context(builder.getSharedContext());
        this._highPassFilterMaterial.name = 'Bloom_highPass';
        this._highPassFilterMaterial.needsUpdate = true;
        // gaussian blur materials
        const kernelSizeArray = [
            3,
            5,
            7,
            9,
            11
        ];
        for(let i = 0; i < this._nMips; i++){
            this._separableBlurMaterials.push(this._getSeparableBlurMaterial(builder, kernelSizeArray[i]));
        }
        // composite material
        const bloomFactors = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["uniformArray"])([
            1.0,
            0.8,
            0.6,
            0.4,
            0.2
        ]);
        const bloomTintColors = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["uniformArray"])([
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](1, 1, 1),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](1, 1, 1),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](1, 1, 1),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](1, 1, 1),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](1, 1, 1)
        ]);
        const lerpBloomFactor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Fn"])(([factor, radius])=>{
            const mirrorFactor = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["float"])(1.2).sub(factor);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mix"])(factor, mirrorFactor, radius);
        }).setLayout({
            name: 'lerpBloomFactor',
            type: 'float',
            inputs: [
                {
                    name: 'factor',
                    type: 'float'
                },
                {
                    name: 'radius',
                    type: 'float'
                }
            ]
        });
        const compositePass = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Fn"])(()=>{
            const color0 = lerpBloomFactor(bloomFactors.element(0), this.radius).mul((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["vec4"])(bloomTintColors.element(0), 1.0)).mul(this._textureNodeBlur0);
            const color1 = lerpBloomFactor(bloomFactors.element(1), this.radius).mul((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["vec4"])(bloomTintColors.element(1), 1.0)).mul(this._textureNodeBlur1);
            const color2 = lerpBloomFactor(bloomFactors.element(2), this.radius).mul((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["vec4"])(bloomTintColors.element(2), 1.0)).mul(this._textureNodeBlur2);
            const color3 = lerpBloomFactor(bloomFactors.element(3), this.radius).mul((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["vec4"])(bloomTintColors.element(3), 1.0)).mul(this._textureNodeBlur3);
            const color4 = lerpBloomFactor(bloomFactors.element(4), this.radius).mul((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["vec4"])(bloomTintColors.element(4), 1.0)).mul(this._textureNodeBlur4);
            const sum = color0.add(color1).add(color2).add(color3).add(color4);
            return sum.mul(this.strength);
        });
        this._compositeMaterial = this._compositeMaterial || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$webgpu$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["NodeMaterial"]();
        this._compositeMaterial.fragmentNode = compositePass().context(builder.getSharedContext());
        this._compositeMaterial.name = 'Bloom_comp';
        this._compositeMaterial.needsUpdate = true;
        //
        return this._textureOutput;
    }
    /**
	 * Frees internal resources. This method should be called
	 * when the effect is no longer required.
	 */ dispose() {
        for(let i = 0; i < this._renderTargetsHorizontal.length; i++){
            this._renderTargetsHorizontal[i].dispose();
        }
        for(let i = 0; i < this._renderTargetsVertical.length; i++){
            this._renderTargetsVertical[i].dispose();
        }
        this._renderTargetBright.dispose();
    }
    /**
	 * Create a separable blur material for the given kernel radius.
	 *
	 * @param {NodeBuilder} builder - The current node builder.
	 * @param {number} kernelRadius - The kernel radius.
	 * @return {NodeMaterial}
	 */ _getSeparableBlurMaterial(builder, kernelRadius) {
        const coefficients = [];
        for(let i = 0; i < kernelRadius; i++){
            coefficients.push(0.39894 * Math.exp(-0.5 * i * i / (kernelRadius * kernelRadius)) / kernelRadius);
        }
        //
        const colorTexture = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["texture"])(null);
        const gaussianCoefficients = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["uniformArray"])(coefficients);
        const invSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["uniform"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"]());
        const direction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["uniform"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"](0.5, 0.5));
        const uvNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["uv"])();
        const sampleTexel = (uv)=>colorTexture.sample(uv);
        const separableBlurPass = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Fn"])(()=>{
            const weightSum = gaussianCoefficients.element(0).toVar();
            const diffuseSum = sampleTexel(uvNode).rgb.mul(weightSum).toVar();
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Loop"])({
                start: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["int"])(1),
                end: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["int"])(kernelRadius),
                type: 'int',
                condition: '<'
            }, ({ i })=>{
                const x = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["float"])(i);
                const w = gaussianCoefficients.element(i);
                const uvOffset = direction.mul(invSize).mul(x);
                const sample1 = sampleTexel(uvNode.add(uvOffset)).rgb;
                const sample2 = sampleTexel(uvNode.sub(uvOffset)).rgb;
                diffuseSum.addAssign((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["add"])(sample1, sample2).mul(w));
                weightSum.addAssign((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["float"])(2.0).mul(w));
            });
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["vec4"])(diffuseSum.div(weightSum), 1.0);
        });
        const separableBlurMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$webgpu$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["NodeMaterial"]();
        separableBlurMaterial.fragmentNode = separableBlurPass().context(builder.getSharedContext());
        separableBlurMaterial.name = 'Bloom_separable';
        separableBlurMaterial.needsUpdate = true;
        // uniforms
        separableBlurMaterial.colorTexture = colorTexture;
        separableBlurMaterial.direction = direction;
        separableBlurMaterial.invSize = invSize;
        return separableBlurMaterial;
    }
}
const bloom = (node, strength, radius, threshold)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nodeObject"])(new BloomNode((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$tsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nodeObject"])(node), strength, radius, threshold));
const __TURBOPACK__default__export__ = BloomNode;
}}),

};

//# sourceMappingURL=node_modules_three_examples_jsm_tsl_display_BloomNode_88adbe37.js.map